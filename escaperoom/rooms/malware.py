
import json
import re
from typing import Dict, List, Optional, Tuple

from escaperoom.location import CurrentRoom
from escaperoom.rooms.base import BaseRoom
from escaperoom.transcript import Transcript


class MalwareRoom(BaseRoom):
    """
    Malware Lab solver.

    Behaviour:
    - Reads data/pro_tree.jsonl (JSON-lines: one JSON object per line).
    - Each record should contain PID and PPID (names may vary: pid/PID/process_id, ppid/PPID/parent).
    - Command text may be under cmd/cmdline/command/exe.
    - Builds a parent->children map, finds plausible start PIDs, DFS-traverses to locate
      any process whose command contains 'curl' or 'scp' (case-insensitive).
    - On success writes to transcript:
        TOKEN[PID]=<terminal_pid>
        EVIDENCE[PID].PATH=[p0->p1->...->terminal_pid]
        EVIDENCE[PID].CMD="<matched command>"
    """

    def __init__(self, transcript: Transcript):
        super().__init__(transcript, CurrentRoom.MALWARE)
        self._exfil_re = re.compile(r"\b(curl|scp)\b", flags=re.IGNORECASE)

    # ---------------- helpers ----------------

    @staticmethod
    def _safe_int(val) -> Optional[int]:
        try:
            return int(val)
        except Exception:
            return None

    def _extract_fields(self, rec: dict) -> Tuple[Optional[int], Optional[int], Optional[str]]:
        """
        Return (pid, ppid, cmd) or (None, ...) if not parseable.
        Tolerant to different key names.
        """
        pid = None
        ppid = None
        cmd = None

        for k in ("pid", "PID", "process_id"):
            if k in rec:
                pid = self._safe_int(rec[k])
                break

        for k in ("ppid", "PPID", "parent"):
            if k in rec:
                ppid = self._safe_int(rec[k])
                break

        for k in ("cmd", "cmdline", "command", "exe"):
            if k in rec and isinstance(rec[k], str):
                cmd = rec[k]
                break

        return pid, ppid, cmd

    def _parse_jsonl(self, fh) -> Tuple[Dict[int, Dict], Dict[int, List[int]]]:
        """
        Parse JSONL into:
         - nodes: pid -> {"pid":pid,"ppid":ppid,"cmd":cmd,"raw":rec}
         - children: ppid -> list of child pids
        Malformed lines are skipped.
        """
        nodes: Dict[int, Dict] = {}
        children: Dict[int, List[int]] = {}

        for line in fh:
            line = line.strip()
            if not line:
                continue
            try:
                rec = json.loads(line)
            except json.JSONDecodeError:
                # skip bad json lines
                continue

            pid, ppid, cmd = self._extract_fields(rec)
            if pid is None:
                # skip records without a usable pid
                continue

            nodes[pid] = {"pid": pid, "ppid": ppid, "cmd": cmd, "raw": rec}
            parent = ppid if ppid is not None else 0
            children.setdefault(parent, []).append(pid)

        return nodes, children

    def _find_start_pids(self, nodes: Dict[int, Dict], children: Dict[int, List[int]]) -> List[int]:
        """
        Determine reasonable roots:
         - If any record explicitly supplies start_pid/startPID/root_pid, use that (first encountered).
         - Else, roots are pids with ppid==0 or whose parent is missing from nodes.
         - Fallback: smallest pid.
        """
        # explicit start fields
        for rec in nodes.values():
            raw = rec.get("raw", {})
            for key in ("start_pid", "startPID", "root_pid"):
                if key in raw:
                    s = self._safe_int(raw[key])
                    if s is not None:
                        return [s]

        roots = []
        for pid, rec in nodes.items():
            ppid = rec.get("ppid")
            if ppid is None or ppid == 0 or ppid not in nodes:
                roots.append(pid)

        if not roots and nodes:
            roots = [min(nodes.keys())]
        return roots

    def _dfs_find_exfil(self, start: int, nodes: Dict[int, Dict], children: Dict[int, List[int]]) -> Optional[Tuple[List[int], str]]:
        """
        self.transcript.print_message("You called solve on " + CurrentRoom.get_room_name(self.current_room))
        self.add_log_totranscript("I did something")
        DFS looking for a node whose cmd matches exfil pattern.
        Returns (path_list, matched_cmd) or None.
        """
        visited = set()

        def dfs(pid: int, path: List[int]) -> Optional[Tuple[List[int], str]]:
            if pid in visited:
                return None
            visited.add(pid)
            path = path + [pid]
            node = nodes.get(pid)
            if node:
                cmd = node.get("cmd") or ""
                if isinstance(cmd, str) and self._exfil_re.search(cmd):
                    return path, cmd
            for child in children.get(pid, []):
                res = dfs(child, path)
                if res:
                    return res
            return None

        return dfs(start, [])

    # ---------------- main solve ----------------

    def solve(self):
        self.transcript.print_message("You called solve on " + CurrentRoom.get_room_name(self.current_room))
        # Sanity marker to ensure new file loaded when testing
        self.transcript.print_message("[MalwareRoom v1] starting traversal")

        try:
            fh = self.open_file()
            if fh is None:
                self.transcript.print_message("proc_tree.jsonl not found in data/.")
                return None

            with fh:
                nodes, children = self._parse_jsonl(fh)

            if not nodes:
                self.transcript.print_message("proc_tree.jsonl contained no usable JSON records.")
                return None

            starts = self._find_start_pids(nodes, children)
            if not starts:
                self.transcript.print_message("No start PID found to begin traversal.")
                return None

            found = None
            # try from plausible starts first
            for s in starts:
                res = self._dfs_find_exfil(s, nodes, children)
                if res:
                    found = res
                    break

            # fallback: try DFS from any node (covers weird trees)
            if not found:
                for pid in list(nodes.keys()):
                    res = self._dfs_find_exfil(pid, nodes, children)
                    if res:
                        found = res
                        break

            if not found:
                self.transcript.print_message("No exfiltrating command (curl/scp) found in process tree.")
                return None

            path, matched_cmd = found
            terminal_pid = path[-1]

            path_str = "->".join(str(p) for p in path)
            self.transcript.print_message(f"[Room MALWARE] Found exfil path: [{path_str}]")
            self.transcript.print_message(f"[Room MALWARE] Matched command: \"{matched_cmd}\"")

            self.add_log_to_transcript(f"TOKEN[PID]={terminal_pid}\n")
            self.add_log_to_transcript(f"EVIDENCE[PID].PATH=[{path_str}]\n")
            self.add_log_to_transcript(f'EVIDENCE[PID].CMD="{matched_cmd}"\n')

            return terminal_pid

        except FileNotFoundError:
            self.transcript.print_message("proc_tree.jsonl not found (FileNotFoundError).")
            return None
        except Exception as e:
            self.transcript.print_message("An error occurred in MalwareRoom:\n" + str(e))
            return None
