"""
MalwareRoom

MALWARE puzzle by:

- Reading a JSON-lines file:  data/proc_tree.jsonl
  (one JSON object per line, but lines may be messy or wrapped).
- Extracting process identifiers (PID/PPID) and the command text from
  flexible field names (pid/PID/process_id, ppid/PPID/parent, cmd/cmdline/command/exe).
- Building a parent→children mapping to represent the process tree.
- Starting from plausible root processes, depth-first searching (DFS) for any
  command containing 'curl' or 'scp' (case-insensitive). Those usually signal
  an exfiltration step.
- When an exfiltration command is found, the *last PID in the path* is the
  token for this room.

Transcript (grader) lines we must write exactly:

    TOKEN[PID]=<terminal_pid>
    EVIDENCE[PID].PATH=[p0->p1->...->terminal_pid]
    EVIDENCE[PID].CMD="<matched command>"

"""

# pylint: disable=too-many-return-statements, too-many-branches

import json
import re
from typing import Dict, List, Optional, Tuple

from escaperoom.location import CurrentRoom
from escaperoom.rooms.base import BaseRoom
from escaperoom.transcript import Transcript


class MalwareRoom(BaseRoom):
    """
    Malware lab solver.

    Flow overview (high level):
      solve()
        ├─ open file (BaseRoom.open_file) → fh
        ├─ _parse_jsonl(fh) → (nodes, children)
        ├─ _find_start_pids(nodes) → list[int]
        ├─ search via _dfs_find_exfil(...) from each start PID
        ├─ if not found, brute-force search from any PID
        └─ when found:
              - format path
              - log TOKEN/EVIDENCE lines
              - return terminal PID as string
    """

    def __init__(self, transcript: Transcript, save_file_path: str):
        """
        Constructor.

        Args:
            transcript: Shared transcript/logger object used by the engine.
            save_file_path: Passed through to BaseRoom for saving progress.

        Also prepares:
            self._exfil_re: compiled regex that matches 'curl' or 'scp'
                            as whole words in a command line (case-insensitive).
        """
        super().__init__(transcript, CurrentRoom.MALWARE, save_file_path)
        self._exfil_re = re.compile(r"\b(curl|scp)\b", flags=re.IGNORECASE)

    # Helpers: small, focused utilities

    def _safe_int(self, val) -> Optional[int]:
        """
        Safely convert a value to int, returning None on failure.

        Why:
            PID/PPID fields might be strings, None, or oddly formatted.
            We do *not* want to crash; we just skip unusable records.

        Returns:
            int(val) if conversion works, otherwise None.
        """
        try:
            return int(val)
        except (TypeError, ValueError) as err:
            self.transcript.print_message(f"[safe_int] Conversion failed: {err}")
            return None

    def _extract_fields(self, rec: dict) -> Tuple[Optional[int], Optional[int], Optional[str]]:
        """
        Extract (pid, ppid, cmd) from a JSON record with tolerant field names.

        Accepted field name variants:
            pid:  "pid", "PID", "process_id"
            ppid: "ppid", "PPID", "parent"
            cmd:  "cmd", "cmdline", "command", "exe"

        Returns:
            (pid, ppid, cmd) — any of these may be None if not present/convertible.
        """
        pid: Optional[int] = None
        ppid: Optional[int] = None
        cmd: Optional[str] = None

        # Try each known PID key until one is present & convertible.
        for key in ("pid", "PID", "process_id"):
            if key in rec:
                pid = self._safe_int(rec[key])
                break

        # Try each known PPID key until one is present & convertible.
        for key in ("ppid", "PPID", "parent"):
            if key in rec:
                ppid = self._safe_int(rec[key])
                break

        # Try each known command field until we find a string.
        for key in ("cmd", "cmdline", "command", "exe"):
            if key in rec and isinstance(rec[key], str):
                cmd = rec[key]
                break

        return pid, ppid, cmd

    def _parse_jsonl(self, fh) -> Tuple[Dict[int, Dict], Dict[int, List[int]]]:
        """
        Parse the JSON-lines file into two structures:
        Returns:
            nodes:    { pid: {"pid": pid, "ppid": ppid, "cmd": cmd, "raw": original_record} }
            children: { ppid: [child_pid, child_pid, ...] }
        Implementation details:
        - Lines can be blank, wrapped, or malformed, try to reassemble wrapped objects
          (simple heuristic: accumulate until we see closing brace) and skip anything that
          still fails to parse.
        - Records without a valid PID are ignored (cannot index them in the tree).
        - Missing/None PPID is treated as 0 (synthetic root).
        """
        nodes: Dict[int, Dict] = {}
        children: Dict[int, List[int]] = {}

        current_json = ""  # accumulates text when a record spans multiple lines
        for raw_line in fh:
            line = raw_line.strip()
            if not line:
                # Skip empty lines
                continue

            # Heuristic to rebuild wrapped JSON objects:
            # - If a line starts with '{' and does not end with '}', start accumulation.
            # - If a line does not start with '{', we keep appending until one ends with '}'.
            # - If it both starts with '{' and ends with '}', it's a complete line.
            if line.startswith("{"):
                current_json = line
                if not line.endswith("}"):
                    # Start of a wrapped object; keep accumulating
                    continue
            elif not line.endswith("}"):
                # Middle of a wrapped object; keep accumulating.
                current_json += line
                continue
            else:
                # End (or complete) of a wrapped object; finalize
                current_json += line

            try:
                rec = json.loads(current_json)
            except json.JSONDecodeError:
                # Bad JSON; skip this object and continue scanning.
                current_json = ""
                continue
            finally:
                # Reset the accumulator regardless of success/failure for the next record.
                current_json = ""

            pid, ppid, cmd = self._extract_fields(rec)
            if pid is None:
                # Without a usable PID we cannot index this node; drop it.
                continue

            # Register this node:
            nodes[pid] = {"pid": pid, "ppid": ppid, "cmd": cmd, "raw": rec}

            # If PPID is None or zero-like, use 0 to represent 'root' parent.
            parent = ppid if ppid is not None else 0
            children.setdefault(parent, []).append(pid)

        return nodes, children

    def _find_start_pids(self, nodes: Dict[int, Dict]) -> List[int]:
        """
        Determine plausible root PIDs from which to begin DFS.
        Strategy:
        1) If any record's 'raw' dict contains one of:
           'start_pid', 'startPID', 'root_pid' → use the first valid one.
        2) Else, gather PIDs whose PPID is 0/None or whose PPID is not present
           as a key in 'nodes' (i.e., parent does not exist in our data).
        3) Fallback: smallest PID, if 'nodes' isn't empty.
        Returns:
            A (possibly empty) list of start PIDs, but we try to ensure it
            has at least one element when 'nodes' is non-empty.
        """
        # (1) explicit start hint inside raw record (first one wins)
        for rec in nodes.values():
            raw = rec.get("raw", {})
            for key in ("start_pid", "startPID", "root_pid"):
                if key in raw:
                    hinted = self._safe_int(raw[key])
                    if hinted is not None:
                        return [hinted]

        # (2) implicit roots: PPID is None/0 OR parent missing from 'nodes'
        roots = [
            pid
            for pid, rec in nodes.items()
            if rec.get("ppid") in (None, 0) or rec.get("ppid") not in nodes
        ]

        # (3) fallback: smallest PID if we found no roots but have nodes
        if not roots and nodes:
            return [min(nodes.keys())]
        return roots

    def _dfs_find_exfil(
        self,
        start: int,
        nodes: Dict[int, Dict],
        children: Dict[int, List[int]],
    ) -> Optional[Tuple[List[int], str]]:
        """
        Depth-first search from a starting PID, looking for a command
        that contains 'curl' or 'scp' (per self._exfil_re).

        Args:
            start:     PID to begin from.
            nodes:     PID → node data mapping.
            children:  PPID → list of child PIDs.

        Returns:
            (path_list, matched_cmd) if a matching command is found, else None.

        Notes:
            We keep a 'visited' set to avoid infinite loops in degenerate trees.
        """
        visited: set[int] = set()

        def dfs(pid: int, path: List[int]) -> Optional[Tuple[List[int], str]]:
            # Avoid cycles
            if pid in visited:
                return None
            visited.add(pid)

            # Extend the current path with this node
            new_path = path + [pid]

            # Examine this node's command
            node = nodes.get(pid)
            if node:
                cmd = node.get("cmd") or ""
                if isinstance(cmd, str) and self._exfil_re.search(cmd):
                    # Found a suspicious command, return the path + command text.
                    return new_path, cmd

            # Recurse into children
            for child_pid in children.get(pid, []):
                result = dfs(child_pid, new_path)
                if result:
                    return result

            return None

        return dfs(start, [])

    # Main solver

    def solve(self) -> Optional[str]:
        """
        Entry point when the player runs `inspect proc_tree.jsonl` in the MALWARE room.

        Steps:
          1) Open and parse 'data/proc_tree.jsonl' into (nodes, children).
          2) Identify plausible start PIDs via explicit hints or inferred roots.
          3) DFS from each start to find 'curl' or 'scp'; if none, brute-force from any PID.
          4) When found, format the path and log official transcript lines.
          5) Return the terminal PID (as string), which is the room's token.

        Returns:
            The terminal PID token (str) if found, otherwise None
        """
        # User facing progress marker so it's obvious this solver ran
        self.transcript.print_message("[MalwareRoom] Starting traversal")

        try:
            # BaseRoom.open_file() looks up the file name for this room via CurrentRoom
            # and opens it from the 'data' directory,for MALWARE that is 'proc_tree.jsonl'.
            fh = self.open_file()
            if fh is None:
                self.transcript.print_message("proc_tree.jsonl not found in data/.")
                return None

            # Build the process graph: nodes + children mapping
            with fh:
                nodes, children = self._parse_jsonl(fh)

            if not nodes:
                self.transcript.print_message("proc_tree.jsonl contained no usable JSON records.")
                return None

            # Compute candidate starting PIDs (explicit hint > inferred roots > fallback).
            starts = self._find_start_pids(nodes)
            if not starts:
                self.transcript.print_message("No start PID found to begin traversal.")
                return None

            # Try DFS from each plausible start first
            found: Optional[Tuple[List[int], str]] = None
            for start_pid in starts:
                found = self._dfs_find_exfil(start_pid, nodes, children)
                if found:
                    break

            # If not found yet, brute-force: attempt a DFS from every PID
            if not found:
                for pid in nodes:
                    found = self._dfs_find_exfil(pid, nodes, children)
                    if found:
                        break

            if not found:
                # Nothing matched 'curl' or 'scp'
                self.transcript.print_message(
                    "No exfiltrating command (curl/scp) found in process tree."
                )
                return None

            #a path and a matched command.
            path, matched_cmd = found
            terminal_pid = path[-1]  # the last PID in the matched chain
            path_str = "->".join(str(p) for p in path)

            # Print user-facing info
            self.transcript.print_message(f"[Room MALWARE] Found exfil path: [{path_str}]")
            self.transcript.print_message(
            "[Room MALWARE] Matched command: "
            f'"{matched_cmd}"'
            )

            # Official grading lines for run.txt (via Transcript)
            self.add_log_to_transcript(f"TOKEN[PID]={terminal_pid}")
            self.add_log_to_transcript(f"EVIDENCE[PID].PATH=[{path_str}]")
            self.add_log_to_transcript(f'EVIDENCE[PID].CMD="{matched_cmd}"')

            # Return the PID as a string (consistent with other rooms)
            return str(terminal_pid)

        except FileNotFoundError:
            # Defensive: BaseRoom.open_file() usually returns None when missing,
            # handle direct errors too.
            self.transcript.print_message("proc_tree.jsonl not found (FileNotFoundError).")
            return None
        except (OSError, ValueError, json.JSONDecodeError) as err:
            # Common I/O/parse failurkes are reported but do not crash the engine.
            self.transcript.print_message(f"Error in MalwareRoom: {err}")
            return None
